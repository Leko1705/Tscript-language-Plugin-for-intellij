{
  parserClass="com.test.language.parser.TestParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Test"
  psiImplClassSuffix="Impl"
  psiPackage="com.test.language.psi"
  psiImplPackage="com.test.language.psi.impl"

  elementTypeHolderClass="com.test.language.psi.TestTypes"
  elementTypeClass="com.test.language.psi.TestElementType"
  tokenTypeClass="com.test.language.psi.TestTokenType"

  extends(".*expr")=expr
}

file ::= (COMMENT | definition | stmt)* {recoverWhile=recover_global}

private definition ::= (NATIVE | ABSTRACT)? FUNCTION function_def | NAMESPACE namespace_def | ABSTRACT? CLASS class_def {pin=1}

namespace_def ::= IDENT CURLY_OPEN definition* CURLY_CLOSE

function_def ::= IDENT params (SEMI | block)
params ::= PAREN_OPEN PAREN_CLOSE | PAREN_OPEN param_list PAREN_CLOSE
private param_list ::= param (COMMA param)* {recoverWhile=recover_params}
param ::= CONST? IDENT (ASSIGN expr)? {pin=1}

class_def ::= IDENT (COLON IDENT)? class_body
private class_body ::= CURLY_OPEN CURLY_CLOSE | CURLY_OPEN class_body_def CURLY_CLOSE
private class_body_def ::= visibility (
visibility | (OVERRIDDEN | STATIC)? definition | constructor_def | var_dec | cost_dec)* {recoverWhile=recover_class}

constructor_def ::= CONSTRUCTOR params (COLON SUPER call)? block {pin=1}
visibility ::= (PUBLIC | PRIVATE | PROTECTED) COLON {pin=1}

private stmt ::= var_dec | cost_dec | block | SEMI | if_else | while_do | do_while | for_loop | try_catch | throw_stmt | break_stmt | continue_stmt | anon_function | expr_stmt
var_dec ::= VAR IDENT (ASSIGN expr)? SEMI {pin=1}
cost_dec ::= CONST IDENT ASSIGN expr SEMI {pin=1}
block ::= CURLY_OPEN stmt_list CURLY_CLOSE {pin=1}
stmt_list ::= stmt* {recoverWhile=recover_stmt}
if_else ::= IF expr THEN stmt (ELSE stmt)? {pin=1}
while_do ::= WHILE expr DO stmt {pin=1}
do_while ::= DO stmt WHILE expr SEMI {pin=1}
for_loop ::= FOR (VAR IDENT IN)? expr DO stmt {pin=1}
try_catch ::= TRY stmt CATCH VAR IDENT DO stmt {pin=1}
throw_stmt ::= THROW expr SEMI {pin=1}
private break_stmt ::= BREAK SEMI {pin=1}
private continue_stmt ::= CONTINUE SEMI {pin=1}
private expr_stmt ::= expr SEMI {pin=1}
private anon_function ::= FUNCTION function_def {pin=1}

expr ::=
 assign_expr
| and_expr
| or_expr
| xor_expr
| eq_expr
| comp_expr
| primary_expr

assign_expr ::= and_expr assign_op assign_expr | and_expr
private assign_op ::= ASSIGN | ADD_ASSIGN | SUB_ASSIGN | MUL_ASSIGN
| DIV_ASSIGN | IDIV_ASSIGN | MOD_ASSIGN | POW_ASSIGN | SAL_ASSIGN | SAR_ASSIGN | SLR_ASSIGN

and_expr ::= or_expr (AND and_expr)*
or_expr ::= xor_expr (OR or_expr)*
xor_expr ::= eq_expr (XOR xor_expr)*

eq_expr ::= comp_expr (eq_op eq_expr)*
private eq_op ::= EQUALS | NOT_EQUALS

comp_expr ::= shift_expr (comp_op comp_expr)*
comp_op ::= GT | GEQ | LT | LEQ | TYPEOF

shift_expr ::= plus_expr (shift_op shift_expr)*
shift_op ::= SAL | SAR | SLR

plus_expr ::= mul_expr (plus_op plus_expr)*
plus_op ::= ADD | SUB

mul_expr ::= pow_expr (mul_op mul_expr)*
mul_op ::= MUL | DIV | IDIV | MOD

pow_expr ::= range_expr (POW pow_expr)*

range_expr ::= unary_expr (COLON unary_expr)?

unary_expr ::= primary_expr (mem_access | container_access | call)* {pin=1}

mem_access ::= DOT IDENT {pin=1}
container_access ::= BRACKET_OPEN expr BRACKET_CLOSE {pin=1}
call ::= PAREN_OPEN arg_list PAREN_CLOSE {pin=1}
arg_list ::= (arg (COMMA arg)*)? {recoverWhile=recover_params}
arg ::= (IDENT ASSIGN)? expr

private primary_expr ::= literal_expr | array_expr | dictionary_expr | lambda_expr | super_access_expr | typeof_prefix_expr | not_expr


private literal_expr ::= TRUE | FALSE | INTEGER | REAL | NULL | STRING | THIS | IDENT

typeof_prefix_expr ::= TYPEOF expr
not_expr ::= NOT expr

array_expr ::= BRACKET_OPEN BRACKET_CLOSE | BRACKET_OPEN array_content BRACKET_CLOSE
private array_content ::= expr (COMMA expr)* {recoverWhile=recover_array}
super_access_expr ::= SUPER DOT IDENT

dictionary_expr ::= CURLY_OPEN CURLY_CLOSE | CURLY_OPEN dictionary_content CURLY_CLOSE
dictionary_content ::= dictionary_entry (COMMA dictionary_entry)* {recoverWhile=recover_dictionary}
dictionary_entry ::= expr COLON expr {pin=1}

lambda_expr ::= FUNCTION closures? params block {pin=1}
closures ::= BRACKET_OPEN BRACKET_CLOSE | BRACKET_OPEN closure_list BRACKET_CLOSE
private closure_list ::= closure (COMMA closure)* {recoverWhile=recover_array}
closure ::= IDENT (ASSIGN expr)? {pin=1}

private recover_global ::= !(SEMI | CURLY_CLOSE | FUNCTION | NATIVE | CLASS | NAMESPACE | VAR | CONST)
private recover_stmt ::= !(SEMI | CURLY_CLOSE)
private recover_params ::= !(PAREN_CLOSE | COMMA | SEMI)
private recover_array ::= !(BRACKET_CLOSE | COMMA | SEMI)
private recover_dictionary ::= !(CURLY_CLOSE | COMMA | SEMI)
private recover_class ::= !(COLON | PUBLIC | PROTECTED | PRIVATE | CONSTRUCTOR | CURLY_CLOSE | SEMI)
